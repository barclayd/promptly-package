import { expect, test } from 'bun:test';
import {
  extractTemplateVariables,
  fetchAllPrompts,
  generateTypeDeclaration,
} from '../cli/generate.ts';
import { createPromptlyClient } from '../client.ts';
import { PromptlyError } from '../errors.ts';

const TEST_API_KEY = process.env.TEST_PROMPT_API_KEY;
const TEST_PROMPT_ID = process.env.TEST_PROMPT_ID;
const hasEnv = Boolean(TEST_API_KEY && TEST_PROMPT_ID);

const setup = () =>
  createPromptlyClient({
    apiKey: TEST_API_KEY!,
  });

test.skipIf(!hasEnv)('smoke: get() fetches a real prompt', async () => {
  const client = setup();
  const result = await client.get(TEST_PROMPT_ID!);

  expect(result.promptId).toBe(TEST_PROMPT_ID!);
  expect(typeof result.systemMessage).toBe('string');
  expect(typeof result.userMessage).toBe('function');
  expect(typeof result.temperature).toBe('number');
});

test.skipIf(!hasEnv)(
  'smoke: get() userMessage interpolates variables',
  async () => {
    const client = setup();
    const result = await client.get(TEST_PROMPT_ID!);

    const template = String(result.userMessage);
    expect(typeof template).toBe('string');

    const varMatches = template.matchAll(/\$\{(\w+)\}/g);
    const variables: Record<string, string> = {};
    for (const match of varMatches) {
      if (match[1]) {
        variables[match[1]] = `test-${match[1]}`;
      }
    }

    if (Object.keys(variables).length > 0) {
      const interpolated = result.userMessage(variables);
      for (const [key, value] of Object.entries(variables)) {
        expect(interpolated).toContain(value);
        expect(interpolated).not.toContain(`\${${key}}`);
      }
    }
  },
);

test.skipIf(!hasEnv)(
  'smoke: getPrompts() fetches multiple prompts',
  async () => {
    const client = setup();
    const results = await client.getPrompts([{ promptId: TEST_PROMPT_ID! }]);

    expect(results).toHaveLength(1);
    expect(results[0].promptId).toBe(TEST_PROMPT_ID!);
    expect(typeof results[0].userMessage).toBe('function');
    expect(typeof results[0].temperature).toBe('number');
  },
);

test.skipIf(!hasEnv)('smoke: aiParams() returns AI SDK params', async () => {
  const client = setup();
  const params = await client.aiParams(TEST_PROMPT_ID!);

  expect(typeof params.system).toBe('string');
  expect(typeof params.prompt).toBe('string');
  expect(typeof params.temperature).toBe('number');
});

test.skipIf(!TEST_API_KEY)(
  'smoke: get() throws PromptlyError for nonexistent prompt',
  async () => {
    const client = setup();

    try {
      await client.get('nonexistent-id-xxx');
      expect.unreachable('Expected PromptlyError to be thrown');
    } catch (error) {
      expect(error).toBeInstanceOf(PromptlyError);
      expect((error as PromptlyError).code).toBe('NOT_FOUND');
    }
  },
);

// --- fetchAllPrompts / codegen ---

test.skipIf(!TEST_API_KEY)(
  'smoke: fetchAllPrompts() returns array of prompts',
  async () => {
    const prompts = await fetchAllPrompts(TEST_API_KEY!);

    expect(Array.isArray(prompts)).toBe(true);
    expect(prompts.length).toBeGreaterThan(0);

    const first = prompts[0]!;
    expect(typeof first.promptId).toBe('string');
    expect(typeof first.systemMessage).toBe('string');
    expect(typeof first.userMessage).toBe('string');
    expect(typeof first.config).toBe('object');
    expect(typeof first.config.temperature).toBe('number');
  },
);

test.skipIf(!hasEnv)(
  'smoke: fetchAllPrompts() includes the test prompt',
  async () => {
    const prompts = await fetchAllPrompts(TEST_API_KEY!);
    const match = prompts.find((p) => p.promptId === TEST_PROMPT_ID);

    expect(match).toBeDefined();
    expect(match!.promptId).toBe(TEST_PROMPT_ID!);
  },
);

test.skipIf(!TEST_API_KEY)(
  'smoke: fetchAllPrompts() throws PromptlyError for invalid key',
  async () => {
    try {
      await fetchAllPrompts('invalid-key-xxx');
      expect.unreachable('Expected PromptlyError to be thrown');
    } catch (error) {
      expect(error).toBeInstanceOf(PromptlyError);
      expect((error as PromptlyError).status).toBe(401);
    }
  },
);

test.skipIf(!TEST_API_KEY)(
  'smoke: generateTypeDeclaration() produces valid declaration from real prompts',
  async () => {
    const prompts = await fetchAllPrompts(TEST_API_KEY!);
    const declaration = generateTypeDeclaration(prompts);

    expect(declaration).toContain(
      '// Auto-generated by @promptlycms/prompts â€” do not edit',
    );
    expect(declaration).toContain("declare module '@promptlycms/prompts'");
    expect(declaration).toContain('interface PromptVariableMap');

    for (const prompt of prompts) {
      expect(declaration).toContain(`// v${prompt.version}`);
      expect(declaration).toContain(`'${prompt.promptId}'`);
      expect(declaration).toContain('latest:');
      const vars = extractTemplateVariables(prompt.userMessage);
      for (const v of vars) {
        expect(declaration).toContain(`${v}: string;`);
      }
    }
  },
);
