import { writeFile } from 'node:fs/promises';
import { createErrorFromResponse } from '../errors.ts';
import type { PromptResponse } from '../types.ts';

const DEFAULT_BASE_URL = 'https://api.promptlycms.com';

export const extractTemplateVariables = (text: string): string[] => {
  const matches = text.matchAll(/\$\{(\w+)\}/g);
  const vars = new Set<string>();
  for (const match of matches) {
    const captured = match[1];
    if (captured) {
      vars.add(captured);
    }
  }
  return [...vars];
};

export const fetchAllPrompts = async (
  apiKey: string,
  baseUrl?: string,
): Promise<PromptResponse[]> => {
  const url = new URL('/prompts', baseUrl ?? DEFAULT_BASE_URL);
  url.searchParams.set('include_versions', 'true');

  const response = await fetch(url.toString(), {
    headers: {
      Authorization: `Bearer ${apiKey}`,
    },
  });

  if (!response.ok) {
    throw await createErrorFromResponse(response);
  }

  return response.json() as Promise<PromptResponse[]>;
};

const generateVariableBlock = (
  variables: string[],
  indent: string,
): string[] => {
  if (variables.length === 0) {
    return [`${indent}Record<string, never>;`];
  }
  const lines: string[] = [`${indent}{`];
  for (const v of variables) {
    lines.push(`${indent}  ${v}: string;`);
  }
  lines.push(`${indent}};`);
  return lines;
};

const generateVersionEntries = (
  label: string,
  userMessage: string,
  indent: string,
): string[] => {
  const variables = extractTemplateVariables(userMessage);
  const block = generateVariableBlock(variables, indent);
  // Replace the leading indent on the first line with the key
  block[0] = `${indent}${label}: ${block[0]?.trimStart()}`;
  return block;
};

export const generateTypeDeclaration = (prompts: PromptResponse[]): string => {
  const lines: string[] = [
    '// Auto-generated by @promptlycms/prompts — do not edit',
    "import '@promptlycms/prompts';",
    '',
    "declare module '@promptlycms/prompts' {",
    '  interface PromptVariableMap {',
  ];

  for (const prompt of prompts) {
    lines.push(`    // v${prompt.version}`);
    lines.push(`    '${prompt.promptId}': {`);

    // latest always maps to the current version's variables
    lines.push(
      ...generateVersionEntries('latest', prompt.userMessage, '      '),
    );

    if (prompt.publishedVersions) {
      for (const pv of prompt.publishedVersions) {
        lines.push(
          ...generateVersionEntries(
            `'${pv.version}'`,
            pv.userMessage,
            '      ',
          ),
        );
      }
    } else {
      // Backward compat: no publishedVersions — duplicate latest as current version
      lines.push(
        ...generateVersionEntries(
          `'${prompt.version}'`,
          prompt.userMessage,
          '      ',
        ),
      );
    }

    lines.push('    };');
  }

  lines.push('  }');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
};

export const generate = async (
  apiKey: string,
  outputPath: string,
  baseUrl?: string,
): Promise<void> => {
  const prompts = await fetchAllPrompts(apiKey, baseUrl);

  if (prompts.length === 0) {
    console.log('  No prompts found for this API key.');
    return;
  }

  console.log(`  Found ${prompts.length} prompt(s)`);

  const content = generateTypeDeclaration(prompts);
  await writeFile(outputPath, content, 'utf-8');
  console.log(`  Generated ${outputPath}`);
};
