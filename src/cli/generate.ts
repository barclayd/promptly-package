import { mkdir, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { createPromptClient } from '../client.ts';
import { schemaFieldsToZodSource } from '../schema/codegen.ts';
import type { PromptEntry, PromptlyConfig, PromptResponse } from '../types.ts';

const extractTemplateVariables = (text: string): string[] => {
  const matches = text.matchAll(/\{\{(\w+)\}\}/g);
  const vars = new Set<string>();
  for (const match of matches) {
    const captured = match[1];
    if (captured) {
      vars.add(captured);
    }
  }
  return [...vars];
};

const toPascalCase = (str: string): string =>
  str
    .replace(/[-_\s]+(.)?/g, (_, c: string | undefined) =>
      c ? c.toUpperCase() : '',
    )
    .replace(/^./, (c) => c.toUpperCase());

const generatePromptFile = (
  entry: PromptEntry,
  prompt: PromptResponse,
): string => {
  const hasSchema = prompt.config.schema && prompt.config.schema.length > 0;
  const variables = extractTemplateVariables(prompt.userMessage);
  const typeName = `${toPascalCase(entry.name)}Output`;

  const lines: string[] = [
    '// Auto-generated by @promptly/prompts — do not edit',
    "import { z } from 'zod';",
  ];

  if (hasSchema) {
    lines.push("import { Output } from 'ai';");
  }

  lines.push('');

  if (hasSchema) {
    const schemaSource = schemaFieldsToZodSource(prompt.config.schema);
    lines.push(`export const ${entry.name}Schema = ${schemaSource};`);
    lines.push('');
    lines.push(
      `export type ${typeName} = z.infer<typeof ${entry.name}Schema>;`,
    );
    lines.push('');
  }

  lines.push(`export const ${entry.name}Prompt = {`);
  lines.push(`  promptId: '${prompt.promptId}',`);
  lines.push(`  promptName: '${escapeString(prompt.promptName)}',`);
  lines.push(`  version: '${prompt.version}',`);
  lines.push(`  system: '${escapeString(prompt.systemMessage)}',`);
  lines.push(`  userMessage: '${escapeString(prompt.userMessage)}',`);
  lines.push(`  temperature: ${prompt.config.temperature},`);
  if (prompt.config.model) {
    lines.push(`  model: '${escapeString(prompt.config.model)}',`);
  }
  lines.push('} as const;');
  lines.push('');

  // Generate the params function
  const varsType =
    variables.length > 0
      ? `{ ${variables.map((v) => `${v}?: string`).join('; ')} }`
      : 'Record<string, string>';

  lines.push('/**');
  lines.push(` * Get AI SDK params for the ${prompt.promptName} prompt.`);
  lines.push(' * Spread into generateText/streamText/generateObject.');
  lines.push(' */');
  lines.push(
    `export const ${entry.name}Params = (variables?: ${varsType}) => {`,
  );
  lines.push(`  let prompt = '${escapeString(prompt.userMessage)}';`);
  lines.push('  if (variables) {');
  lines.push('    for (const [key, value] of Object.entries(variables)) {');
  // biome-ignore lint/suspicious/noTemplateCurlyInString: generated code output
  lines.push("      prompt = prompt.replaceAll(`{{${key}}}`, value ?? '');");
  lines.push('    }');
  lines.push('  }');

  if (hasSchema) {
    lines.push('  return {');
    lines.push(`    system: ${entry.name}Prompt.system,`);
    lines.push('    prompt,');
    lines.push(`    temperature: ${entry.name}Prompt.temperature,`);
    lines.push(`    output: Output.object({ schema: ${entry.name}Schema }),`);
    lines.push('  };');
  } else {
    lines.push('  return {');
    lines.push(`    system: ${entry.name}Prompt.system,`);
    lines.push('    prompt,');
    lines.push(`    temperature: ${entry.name}Prompt.temperature,`);
    lines.push('  };');
  }

  lines.push('};');
  lines.push('');

  return lines.join('\n');
};

const generateBarrelFile = (entries: PromptEntry[]): string => {
  const lines = ['// Auto-generated by @promptly/prompts — do not edit', ''];
  for (const entry of entries) {
    lines.push(`export * from './${entry.name}.ts';`);
  }
  lines.push('');
  return lines.join('\n');
};

const escapeString = (str: string): string =>
  str.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');

export const generate = async (config: PromptlyConfig): Promise<void> => {
  const client = createPromptClient({
    apiKey: config.apiKey,
  });

  const outputDir = config.outputDir ?? './src/generated/prompts';
  await mkdir(outputDir, { recursive: true });

  const results: PromptEntry[] = [];

  for (const entry of config.prompts) {
    console.log(`  Fetching "${entry.name}" (${entry.id})...`);

    const prompt = await client.get(entry.id, {
      version: entry.version,
    });

    const content = generatePromptFile(entry, prompt);
    const filePath = join(outputDir, `${entry.name}.ts`);
    await writeFile(filePath, content, 'utf-8');
    results.push(entry);

    console.log(`  Generated ${filePath}`);
  }

  const barrelContent = generateBarrelFile(results);
  const barrelPath = join(outputDir, 'index.ts');
  await writeFile(barrelPath, barrelContent, 'utf-8');
  console.log(`  Generated ${barrelPath}`);
};
